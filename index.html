<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <title>Vẽ + Đẩy Nét Xịn</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #111;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        color: #fff;
        font-family: sans-serif;
      }
      canvas {
        border: 2px solid #fff;
        background: #222;
        cursor: crosshair;
        touch-action: none; /* quan trọng để vẽ touch không cuộn màn hình */
      }
      #info {
        max-width: 800px;
        text-align: center;
        margin-bottom: 10px;
      }
      button {
        margin-top: 10px;
        padding: 5px 10px;
        font-size: 16px;
        cursor: pointer;
      }
      #score {
        margin-top: 5px;
        font-size: 18px;
      }

      /* joystick */
      #joystick {
        position: absolute;
        bottom: 50px;
        left: 50%;
        transform: translateX(-50%);
        width: 80px;
        height: 80px;
        background: rgba(255, 0, 0, 0.5);
        border-radius: 50%;
        touch-action: none;
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="info">
      Vẽ bằng chuột hoặc tay trên điện thoại, nhấn "Hoàn thành" rồi điều khiển
      nhân vật. Chạm vào nét sẽ đổi màu nhân vật, đẩy nét và tạo particle!
    </div>
    <canvas id="canvas" width="800" height="600"></canvas>
    <button id="finishBtn">Hoàn thành</button>
    <div id="score">Điểm: 0</div>

    <!-- Joystick -->
    <div id="joystick"></div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const finishBtn = document.getElementById("finishBtn");
      const scoreDiv = document.getElementById("score");
      const joystick = document.getElementById("joystick");

      const isTouchDevice =
        "ontouchstart" in window || navigator.maxTouchPoints > 0;

      let drawing = false,
        canDraw = true,
        lastX = 0,
        lastY = 0;
      const lines = [];
      let score = 0;

      // Vẽ bằng chuột
      canvas.addEventListener("mousedown", (e) => {
        if (!canDraw) return;
        drawing = true;
        lastX = e.offsetX;
        lastY = e.offsetY;
      });
      canvas.addEventListener("mousemove", (e) => {
        if (!drawing || !canDraw) return;
        drawLine(lastX, lastY, e.offsetX, e.offsetY);
        lastX = e.offsetX;
        lastY = e.offsetY;
      });
      canvas.addEventListener("mouseup", () => (drawing = false));
      canvas.addEventListener("mouseout", () => (drawing = false));

      // Vẽ bằng touch
      canvas.addEventListener("touchstart", (e) => {
        if (!canDraw) return;
        e.preventDefault();
        const touch = e.touches[0];
        drawing = true;
        lastX = touch.clientX - canvas.getBoundingClientRect().left;
        lastY = touch.clientY - canvas.getBoundingClientRect().top;
      });
      canvas.addEventListener("touchmove", (e) => {
        if (!drawing || !canDraw) return;
        e.preventDefault();
        const touch = e.touches[0];
        const x = touch.clientX - canvas.getBoundingClientRect().left;
        const y = touch.clientY - canvas.getBoundingClientRect().top;
        drawLine(lastX, lastY, x, y);
        lastX = x;
        lastY = y;
      });
      canvas.addEventListener("touchend", () => (drawing = false));
      canvas.addEventListener("touchcancel", () => (drawing = false));

      function drawLine(x1, y1, x2, y2) {
        ctx.strokeStyle = "lime";
        ctx.lineWidth = 3;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        lines.push({ x1, y1, x2, y2, vx: 0, vy: 0 });
      }

      // Player
      const player = {
        x: 400,
        y: 300,
        size: 15,
        color: "red",
        speed: 5,
        trail: [],
      };

      // Particles
      const particles = [];
      function createParticles(x, y, color) {
        for (let i = 0; i < 10; i++) {
          particles.push({
            x,
            y,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            life: 30 + Math.random() * 20,
            color,
          });
        }
      }

      // Va chạm + đẩy
      function checkCollisionAndPush() {
        for (let line of lines) {
          const { x1, y1, x2, y2 } = line;
          const A = player.x - x1,
            B = player.y - y1,
            C = x2 - x1,
            D = y2 - y1;
          const dot = A * C + B * D,
            len_sq = C * C + D * D;
          let param = -1;
          if (len_sq != 0) param = dot / len_sq;
          let xx, yy;
          if (param < 0) {
            xx = x1;
            yy = y1;
          } else if (param > 1) {
            xx = x2;
            yy = y2;
          } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
          }
          const dx = player.x - xx,
            dy = player.y - yy,
            dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < player.size) {
            player.color = `hsl(${Math.random() * 360},100%,50%)`;
            const pushStrength = (player.size - dist) / 2;
            const pushX = (dx / dist) * pushStrength;
            const pushY = (dy / dist) * pushStrength;
            line.vx += pushX;
            line.vy += pushY;
            score += Math.floor(pushStrength * 10);
            createParticles(xx, yy, "lime");
          }
        }
      }

      // Joystick
      let moving = false;
      let moveDir = { x: 0, y: 0 };

      if (isTouchDevice) {
        joystick.addEventListener("touchstart", (e) => {
          e.preventDefault();
          moving = true;
        });

        joystick.addEventListener("touchmove", (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          const rect = joystick.getBoundingClientRect();
          const dx = touch.clientX - (rect.left + rect.width / 2);
          const dy = touch.clientY - (rect.top + rect.height / 2);
          const dist = Math.sqrt(dx * dx + dy * dy);
          moveDir.x = dx / Math.max(dist, 1);
          moveDir.y = dy / Math.max(dist, 1);
        });

        joystick.addEventListener("touchend", (e) => {
          e.preventDefault();
          moving = false;
          moveDir.x = 0;
          moveDir.y = 0;
        });
      }

      // W/A/S/D cho PC
      const keys = {};
      if (!isTouchDevice) {
        document.addEventListener(
          "keydown",
          (e) => (keys[e.key.toLowerCase()] = true)
        );
        document.addEventListener(
          "keyup",
          (e) => (keys[e.key.toLowerCase()] = false)
        );
      }

      // Nút hoàn thành
      finishBtn.addEventListener("click", () => {
        canDraw = false;
        finishBtn.disabled = true;
        finishBtn.textContent = "Đã hoàn thành";
        canvas.style.cursor = "default";

        if (isTouchDevice) joystick.style.display = "block";
      });

      // Cập nhật
      function update() {
        if (!canDraw) {
          if (isTouchDevice) {
            if (moving) {
              player.x += player.speed * moveDir.x;
              player.y += player.speed * moveDir.y;
            }
          } else {
            if (keys["w"]) player.y -= player.speed;
            if (keys["s"]) player.y += player.speed;
            if (keys["a"]) player.x -= player.speed;
            if (keys["d"]) player.x += player.speed;
          }

          // Giữ trong canvas
          player.x = Math.max(
            player.size,
            Math.min(canvas.width - player.size, player.x)
          );
          player.y = Math.max(
            player.size,
            Math.min(canvas.height - player.size, player.y)
          );

          player.trail.push({ x: player.x, y: player.y });
          if (player.trail.length > 20) player.trail.shift();
          checkCollisionAndPush();
        }

        // Cập nhật lines
        for (let line of lines) {
          line.x1 += line.vx;
          line.y1 += line.vy;
          line.x2 += line.vx;
          line.y2 += line.vy;
          line.vx *= 0.9;
          line.vy *= 0.9;
        }

        // Cập nhật particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.1;
          p.life--;
          if (p.life <= 0) particles.splice(i, 1);
        }

        scoreDiv.textContent = "Điểm: " + score;
      }

      // Vẽ player
      function drawPlayer() {
        ctx.beginPath();
        for (let i = 0; i < player.trail.length - 1; i++) {
          ctx.strokeStyle = `rgba(255,0,0,${i / player.trail.length})`;
          ctx.lineWidth = player.size * 0.5 * (i / player.trail.length);
          ctx.moveTo(player.trail[i].x, player.trail[i].y);
          ctx.lineTo(player.trail[i + 1].x, player.trail[i + 1].y);
        }
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
        ctx.fillStyle = player.color;
        ctx.shadowColor = player.color;
        ctx.shadowBlur = 15;
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      function drawLines() {
        ctx.strokeStyle = "lime";
        ctx.lineWidth = 3;
        ctx.lineCap = "round";
        for (let line of lines) {
          ctx.beginPath();
          ctx.moveTo(line.x1, line.y1);
          ctx.lineTo(line.x2, line.y2);
          ctx.stroke();
        }
      }

      function drawParticles() {
        for (let p of particles) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
          ctx.fillStyle = p.color;
          ctx.fill();
        }
      }

      // Loop
      function loop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawLines();
        update();
        drawPlayer();
        drawParticles();
        requestAnimationFrame(loop);
      }

      loop();
    </script>
  </body>
</html>
